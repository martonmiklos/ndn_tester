// This file is generated by KDAB's kdwsdl2cpp from Monitoring.svc?wsdl.
// All changes you do to this file will be lost.
/*
    You may use and relicense this generated file without restriction.
*/
#ifndef MONITORING_H
#define MONITORING_H

#include <QtCore/QString>
#include <QSharedPointer>
#include <QtCore/QSharedData>
#include <KDSoapClient/KDDateTime.h>
#include <QtCore/QList>
#include <KDSoapClient/KDSoapValue.h>
#include <KDSoapClient/KDSoapJob.h>
#include <QtCore/QObject>
#include <KDSoapClient/KDSoapClientInterface.h>

#undef daylight
#undef timezone
class KDSoapMessage;
class KDSoapPendingCallWatcher;
class KDSoapValue;
namespace NSMonitoring {
    class Monitoring;
    class NDN__ArrayOfColumn;
    class NDN__ArrayOfRecord;
    class NDN__ArrayOfTableContent;
    class NDN__Column;
    class NDN__Entity;
    class NDN__MovementType;
    class NDN__Record;
    class NDN__TableContent;
}


namespace NSMonitoring {
    class NDN_COMM__GetDocument
    {
    public:
        void setShopId( const QString& arg_shopId );
        QString shopId() const;
        bool hasValueForShopId() const;
        void setLocalDocumentId( const QString& arg_localDocumentId );
        QString localDocumentId() const;
        bool hasValueForLocalDocumentId() const;
        void setMovementType( const NSMonitoring::NDN__MovementType& arg_movementType );
        NSMonitoring::NDN__MovementType movementType() const;
        bool hasValueForMovementType() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__GetDocument();
        ~NDN_COMM__GetDocument();

    public:
        NDN_COMM__GetDocument( const NDN_COMM__GetDocument& );
        NDN_COMM__GetDocument &operator=( const NDN_COMM__GetDocument& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN_COMM__GetDocumentResponse
    {
    public:
        void setGetDocumentResult( const NSMonitoring::NDN__Entity& arg_getDocumentResult );
        NSMonitoring::NDN__Entity getDocumentResult() const;
        bool hasValueForGetDocumentResult() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__GetDocumentResponse();
        ~NDN_COMM__GetDocumentResponse();

    public:
        NDN_COMM__GetDocumentResponse( const NDN_COMM__GetDocumentResponse& );
        NDN_COMM__GetDocumentResponse &operator=( const NDN_COMM__GetDocumentResponse& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN_COMM__GetOpeningStock
    {
    public:
        void setShopId( const QString& arg_shopId );
        QString shopId() const;
        bool hasValueForShopId() const;
        void setCreationDate( const KDDateTime& arg_creationDate );
        KDDateTime creationDate() const;
        bool hasValueForCreationDate() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__GetOpeningStock();
        ~NDN_COMM__GetOpeningStock();

    public:
        NDN_COMM__GetOpeningStock( const NDN_COMM__GetOpeningStock& );
        NDN_COMM__GetOpeningStock &operator=( const NDN_COMM__GetOpeningStock& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN_COMM__GetOpeningStockResponse
    {
    public:
        void setGetOpeningStockResult( const NSMonitoring::NDN__Entity& arg_getOpeningStockResult );
        NSMonitoring::NDN__Entity getOpeningStockResult() const;
        bool hasValueForGetOpeningStockResult() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__GetOpeningStockResponse();
        ~NDN_COMM__GetOpeningStockResponse();

    public:
        NDN_COMM__GetOpeningStockResponse( const NDN_COMM__GetOpeningStockResponse& );
        NDN_COMM__GetOpeningStockResponse &operator=( const NDN_COMM__GetOpeningStockResponse& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN_COMM__Wait
    {
    public:
        void setSec( int arg_sec );
        int sec() const;
        bool hasValueForSec() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__Wait();
        ~NDN_COMM__Wait();

    public:
        NDN_COMM__Wait( const NDN_COMM__Wait& );
        NDN_COMM__Wait &operator=( const NDN_COMM__Wait& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN_COMM__WaitResponse
    {
    public:
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN_COMM__WaitResponse();
        ~NDN_COMM__WaitResponse();

    };
} // namespace end

namespace NSMonitoring {
    class NDN__ArrayOfColumn
    {
    public:
        void setColumn( const QList< NSMonitoring::NDN__Column >& arg_column );
        QList< NSMonitoring::NDN__Column > column() const;
        bool hasValueForColumn() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__ArrayOfColumn();
        ~NDN__ArrayOfColumn();

    public:
        NDN__ArrayOfColumn( const NDN__ArrayOfColumn& );
        NDN__ArrayOfColumn &operator=( const NDN__ArrayOfColumn& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__ArrayOfRecord
    {
    public:
        void setRecord( const QList< NSMonitoring::NDN__Record >& arg_record );
        QList< NSMonitoring::NDN__Record > record() const;
        bool hasValueForRecord() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__ArrayOfRecord();
        ~NDN__ArrayOfRecord();

    public:
        NDN__ArrayOfRecord( const NDN__ArrayOfRecord& );
        NDN__ArrayOfRecord &operator=( const NDN__ArrayOfRecord& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__ArrayOfTableContent
    {
    public:
        void setTableContent( const QList< NSMonitoring::NDN__TableContent >& arg_tableContent );
        QList< NSMonitoring::NDN__TableContent > tableContent() const;
        bool hasValueForTableContent() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__ArrayOfTableContent();
        ~NDN__ArrayOfTableContent();

    public:
        NDN__ArrayOfTableContent( const NDN__ArrayOfTableContent& );
        NDN__ArrayOfTableContent &operator=( const NDN__ArrayOfTableContent& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__Column
    {
    public:
        void setName( const QString& arg_name );
        QString name() const;
        bool hasValueForName() const;
        void setTypeName( const QString& arg_typeName );
        QString typeName() const;
        bool hasValueForTypeName() const;
        void setValue( const KDSoapValue& arg_value );
        KDSoapValue value() const;
        bool hasValueForValue() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__Column();
        ~NDN__Column();

    public:
        NDN__Column( const NDN__Column& );
        NDN__Column &operator=( const NDN__Column& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__Entity
    {
    public:
        void setTables( const NSMonitoring::NDN__ArrayOfTableContent& arg_tables );
        NSMonitoring::NDN__ArrayOfTableContent tables() const;
        bool hasValueForTables() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__Entity();
        ~NDN__Entity();

    public:
        NDN__Entity( const NDN__Entity& );
        NDN__Entity &operator=( const NDN__Entity& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    /**
        This class is a wrapper for an enumeration.
        Whenever you have to pass an object of type NDN__MovementType you can
        also pass the enum directly.
        Example:
        someMethod(NDN__MovementType::AB).
     */
    class NDN__MovementType
    {
    public:
        enum Type { AB, ABS, BET, BETS, SVISZ, SVISZS, KIT, KITS, LELTT, LELTH, EGYT, EGYJ, ASZLA, ASZLAS, NY, NYS, KSZLA, KSZLAS, VVISZ };

    public:
        NDN__MovementType( const Type &type );
        void setType( Type type );
        NSMonitoring::NDN__MovementType::Type type() const;
        operator Type() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__MovementType();
        ~NDN__MovementType();

    private:
        Type mType;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__Record
    {
    public:
        void setColumns( const NSMonitoring::NDN__ArrayOfColumn& arg_columns );
        NSMonitoring::NDN__ArrayOfColumn columns() const;
        bool hasValueForColumns() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__Record();
        ~NDN__Record();

    public:
        NDN__Record( const NDN__Record& );
        NDN__Record &operator=( const NDN__Record& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class NDN__TableContent
    {
    public:
        void setRecords( const NSMonitoring::NDN__ArrayOfRecord& arg_records );
        NSMonitoring::NDN__ArrayOfRecord records() const;
        bool hasValueForRecords() const;
        void setTableName( const QString& arg_tableName );
        QString tableName() const;
        bool hasValueForTableName() const;
        KDSoapValue serialize( const QString& valueName ) const;
        void deserialize( const KDSoapValue& mainValue );
        NDN__TableContent();
        ~NDN__TableContent();

    public:
        NDN__TableContent( const NDN__TableContent& );
        NDN__TableContent &operator=( const NDN__TableContent& );

    private:
        class PrivateDPtr;
        QSharedDataPointer<PrivateDPtr> d_ptr;
    };
} // namespace end

namespace NSMonitoring {
    class GetDocumentJob : public KDSoapJob
    {
        Q_OBJECT

    public:
        GetDocumentJob( NSMonitoring::Monitoring* service, QObject* _parent = nullptr );
        void setParameters( const NSMonitoring::NDN_COMM__GetDocument& arg0 );
        NSMonitoring::NDN_COMM__GetDocument parameters() const;
        NSMonitoring::NDN_COMM__GetDocumentResponse resultParameters() const;

    protected:
        virtual void doStart() override;

    private Q_SLOTS:
        void slotFinished( KDSoapPendingCallWatcher* watcher );

    private:
        NSMonitoring::Monitoring *mService;
        NSMonitoring::NDN_COMM__GetDocument mParameters;
        NSMonitoring::NDN_COMM__GetDocumentResponse mResultParameters;
    };
} // namespace end

namespace NSMonitoring {
    class GetOpeningStockJob : public KDSoapJob
    {
        Q_OBJECT

    public:
        GetOpeningStockJob( NSMonitoring::Monitoring* service, QObject* _parent = nullptr );
        void setParameters( const NSMonitoring::NDN_COMM__GetOpeningStock& arg0 );
        NSMonitoring::NDN_COMM__GetOpeningStock parameters() const;
        NSMonitoring::NDN_COMM__GetOpeningStockResponse resultParameters() const;

    protected:
        virtual void doStart() override;

    private Q_SLOTS:
        void slotFinished( KDSoapPendingCallWatcher* watcher );

    private:
        NSMonitoring::Monitoring *mService;
        NSMonitoring::NDN_COMM__GetOpeningStock mParameters;
        NSMonitoring::NDN_COMM__GetOpeningStockResponse mResultParameters;
    };
} // namespace end

namespace NSMonitoring {
    class WaitJob : public KDSoapJob
    {
        Q_OBJECT

    public:
        WaitJob( NSMonitoring::Monitoring* service, QObject* _parent = nullptr );
        void setParameters( const NSMonitoring::NDN_COMM__Wait& arg0 );
        NSMonitoring::NDN_COMM__Wait parameters() const;
        NSMonitoring::NDN_COMM__WaitResponse resultParameters() const;

    protected:
        virtual void doStart() override;

    private Q_SLOTS:
        void slotFinished( KDSoapPendingCallWatcher* watcher );

    private:
        NSMonitoring::Monitoring *mService;
        NSMonitoring::NDN_COMM__Wait mParameters;
        NSMonitoring::NDN_COMM__WaitResponse mResultParameters;
    };
} // namespace end

namespace NSMonitoring {
    class Monitoring : public QObject
    {
        Q_OBJECT

    public:
        Monitoring( QObject* _parent = nullptr );
        ~Monitoring();
        /**
            Asks Qt to ignore ssl errors in https requests. Use this for
            testing only!
         */
        void ignoreSslErrors();
        /**
            Overwrite the end point defined in the .wsdl file, with another
            http/https URL.
         */
        void setEndPoint( const QString& endPoint );
        /**
            Return the end point that will be used.
         */
        QString endPoint() const;
        /**
            Overwrite the soap version defined in the .wsdl file, with another
            version.
            version can be KDSoapClientInterface::SOAP1_1 or
            KDSoapClientInterface::SOAP1_2
         */
        void setSoapVersion( KDSoapClientInterface::SoapVersion soapVersion );
        /**
            Return the soap version used.n
         */
        KDSoapClientInterface::SoapVersion soapVersion() const;
        /**
            Return the fault code from the last blocking call.
            Empty if no error.
         */
        int lastErrorCode() const;
        /**
            Return the fault code from the last blocking call.
            Empty if no error.
         */
        QString lastFaultCode() const;
        /**
            Return the error from the last blocking call.
            Empty if no error.
         */
        QString lastError() const;
        /**
            Returns the underlying KDSoapClientInterface instance, which allows
            to access setCookieJar, lastResponseHeaders, etc.
         */
        const KDSoapClientInterface *clientInterface() const;
        KDSoapClientInterface *clientInterface();
        /**
            Blocking call to GetDocument.
            Not recommended in a GUI thread.
         */
        NSMonitoring::NDN_COMM__GetDocumentResponse getDocument( const NSMonitoring::NDN_COMM__GetDocument& parameters );
        /**
            Asynchronous call to GetDocument.
            Remember to connect to getDocumentDone and
            getDocumentError.
            Deprecated, use GetDocumentJob instead.
         */
        void asyncGetDocument( const NSMonitoring::NDN_COMM__GetDocument& parameters );
        /**
            Blocking call to GetOpeningStock.
            Not recommended in a GUI thread.
         */
        NSMonitoring::NDN_COMM__GetOpeningStockResponse getOpeningStock( const NSMonitoring::NDN_COMM__GetOpeningStock& parameters );
        /**
            Asynchronous call to GetOpeningStock.
            Remember to connect to getOpeningStockDone and
            getOpeningStockError.
            Deprecated, use GetOpeningStockJob instead.
         */
        void asyncGetOpeningStock( const NSMonitoring::NDN_COMM__GetOpeningStock& parameters );
        /**
            Blocking call to Wait.
            Not recommended in a GUI thread.
         */
        NSMonitoring::NDN_COMM__WaitResponse wait( const NSMonitoring::NDN_COMM__Wait& parameters );
        /**
            Asynchronous call to Wait.
            Remember to connect to waitDone and waitError.
            Deprecated, use WaitJob instead.
         */
        void asyncWait( const NSMonitoring::NDN_COMM__Wait& parameters );

    Q_SIGNALS:
        /**
            This signal is emitted whenever a SOAP call failed, for a central
            processing of all SOAP errors.
            method is the name of the method (or operation) that returned the
            fault, for instance "addContact".
         */
        void soapError( const QString& method, const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the asynchronous call
            asyncGetDocument() has succeeded.
         */
        void getDocumentDone( const NSMonitoring::NDN_COMM__GetDocumentResponse& parameters );
        /**
            This signal is emitted whenever the asynchronous call
            asyncGetDocument() has failed.
         */
        void getDocumentError( const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the asynchronous call
            asyncGetOpeningStock() has succeeded.
         */
        void getOpeningStockDone( const NSMonitoring::NDN_COMM__GetOpeningStockResponse& parameters );
        /**
            This signal is emitted whenever the asynchronous call
            asyncGetOpeningStock() has failed.
         */
        void getOpeningStockError( const KDSoapMessage& fault );
        /**
            This signal is emitted whenever the asynchronous call asyncWait()
            has succeeded.
         */
        void waitDone( const NSMonitoring::NDN_COMM__WaitResponse& parameters );
        /**
            This signal is emitted whenever the asynchronous call asyncWait()
            has failed.
         */
        void waitError( const KDSoapMessage& fault );

    private Q_SLOTS:
        void _kd_slotGetDocumentFinished( KDSoapPendingCallWatcher* watcher );
        void _kd_slotGetOpeningStockFinished( KDSoapPendingCallWatcher* watcher );
        void _kd_slotWaitFinished( KDSoapPendingCallWatcher* watcher );

    private:
        class PrivateDPtr;
        PrivateDPtr *d_ptr;
    };
} // namespace end

#endif
